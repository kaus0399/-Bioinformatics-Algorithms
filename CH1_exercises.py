from Bio.Seq import Seq
from Bio import SeqIO

#COUNT FUNCTION
def PatternCount(text,pattern):
    count = 0
    for i in range(0,len(text)-len(pattern)+1):
        if text[i:i+len(pattern)] == pattern:
            count = count + 1
    return count       

# print(PatternCount("enter text", "enter pattern"))


#INDEX OF OCCURENCE FUNCTION
def PatternMatching(Genome,pattern):
    occurence_indices = []
    for i in range(0,len(Genome)-len(pattern)+1):
        if Genome[i:i+len(pattern)] == pattern:
            occurence_indices.append(i)
    for x in occurence_indices:
        print(x, " ")   


#(PatternMatching("enter Genome","enter pattern"))




#SAMPLE USAGE OF BIOPYTHON
# dna_seq = Seq("TAATTGATGGTGGGGGCGGCCTAGTATGTCTTGAATATTGCCTGCGGCTGTCTCCTATGGAGGAGCACTAATAGTTCTGGTCGACCTGACGACTAAGCAGAAGCAGTAGAACGTCGGCCGGTTTCACCCTCTGTGGGTTTTTCTCGGTAGTGCGGCAACTTACACGAAGCATTAGCTGCGGATTCGGCGCAGACCTCAGCCGTGTAGTTATTATGGGTTAGGAGCTGACGGCCGTCATGTCACGTTGGACCGCCACCCGGAAGTCCGATAAGAAGTAGGAAGCGTAGTTCAGGGGCGTAATGGCTTAGCTTCTATAGGTTTAGAGCGGCTAGTGGGACGTATTAAAAATGAGCACTTCCCACTGCTAATTTCTATCTACGACGTCCTATTCCAGCCATCGTCGTGTGTCTCAAAATGCGGAAGAGGGGTACGACACTTCCAAATGCTAGGAGAGACCACACAGAGTAGACGGCTGCTTCCGCAATAGACTCGTGTGACATAGTACTTCCTATGTGCGCTCGTTCAGTTCATCGTCGACTTGTATCTCCAGATGTCCATAGTCAGTTCAAGGGAGGTTCCTGCCGATTAGTGAAACACTGTGTAATTCCGCTTGGCAAGGGATGACACAGACGTTTGACGATCATAAACGCCTTCTACAGCCTTCCCTGGGAAACTCGTTCTTAAGTTGCCTTGGGCTCAGCAGACGAGTGTGAGCGCGCCGCTAAGCGAACGGGCCTATATGGTTCAGGCATCATCATCTCAGTATAGTTAGCTTGTATTAGGTGTAACTGCCTCGTTCTTCTGAGTCCCGTCGATCCGATCGTAATCTTTTATAGGAGGGGCCTCGAGTTTTATCCACTTTAGCTTAAGACGGTGTGATTTCATGTCGAGCGTCAAACTTGTACACCATAACGGTACTTCGGCTCTCCGAAACCGGTGAAATCGACAAATATCAGATAGAGATGACTGGATGCCGGGAATCGGCTCATATAATTGCTGGCGCGGACGGCAGACACACTCGGGCTGTCCAGAACTGATAGAGCTCTGCATTTTCGCCACGCCCGTTCCCAGTAGGTATGTGATTGGCCTACCGCGGTGGTAGCCCTAACATCAATGAAACTCAGGCTGCCATAACTGGTCAATGGCCTATTCAATAGCACATCAGCATCCAATTGTGAGAGAACAATACTGCCAAAGTAATTTCACCCGGGTGTTGCGTGCCCCACAGGGGAGTGAGAGCTTAAGCAGAGATTTGGTTCGGCCGGCTGACACACTCCAAACCGTTCGCAAATACGCAGCCGATTGGACTCCCAAACTACGTCTAAACCGCTGCATGTAATGAACTATAAACGTCGGCGCTGTTTTCCGCGACGCTAAGCCGAGTGGTTATAGAAATTAGCGATTCGGGTAATAGCGTTGCGGTGACTACTTAGACAGACGGAACTTTAAAATAACAGCTGTCAGGCACGTCTGCATACTGACACCGTCAAAATGACACTGTTTCCTTGCCTTCACCAGACTTTTTACAGCGCGGTTTTGACTAATAGAAATTGGAGTCGAAATATAATGCGTCCTCACAACTCAGACAATGGGTTAACCAAGTTGCGAGACGGCAGGACTCAAGCTCCCAAGGTCGAAACCTTCTGCCTTACTGAAGTCTAATCGAATATGGCAGGGCGGCGTATTTGGTGCAAGTTGGCTACCTCGACGTGCCGCGGCCCCACTATGTTATCCTGTCATCCAGAGCCTGCGATTCTGTGAACTAGACATATGTACGAGCTCGCGCTCTTCCCGTTACTTAGCGTACTAGACTGCAAACTTGACCGGCGTGCTTCCAAGAGGTGTCGTACGTATATCAAATTGGCTACAATTGGCGCGATCCTAGAGTGGGGACGGTGACGGGTGAAAGTCCTGTGGAATGCGGTACTAGGAGTCCTCAATAGACATCAGCGAGCTGAGGGCACGTCGGTTAAAAACTCGTATCCGCCCGAGGGTGCGGCCCACCTAATGTACGCCAAAACTTGCTAGAAGAATATGCGGGGCTCGCATTCCCCACTAGGGCAAGGAAACCGATGCACTTGTAGATCATGAGACCTCTGCCCCTCACTGCCCCCGCAATTCGATGTCAGTTGACGGCTGCTGCTCGAACGATATGTGTGGTTTTCATCAACCCAAAAAACATGAGCATAGCTGAAGTTCCGTGGGCGGGTCAGCGTGGTCGCATTTGAAAGATCTAAGCGTGGATCGGCAAAACAGCAAAGTCAGCGATTCCAGTAGGAGGTTCCCTGGGCCGTATAACGGCAGGGTTATCGCGCTGATTAGAACGTTTTAAACCTATATTGTGAAGTTTGGTGATGCCCGAGCTACCATGCAGTATGACCCTGTCCTGCAGTTGGAGGGGTCCCCACGGGGACTTTCGGTGATCTCCCCTAGTCTATCGGCAACGTTTTACGTGCTTCCATCTAGCGGATTTCCTCGGAACAGAATCTTACTCATGTCATATAGAAGTGTCGGGTGTAGACAGCCACAAAGTTCGTTGATATTATGCCTGCCAGAATCTCTGGGTACAGTATCCAGAAGGAAAAAAAATCGAGGCGGCTCGTTTAACGAGCATTGGACCGTGAGCCCAAACAATAACAATAGGACTCGTACGATACTGGCTACATAATCGAAGGGCTTCCATTGAGCTTCGTCCATCACCACACGACTTTGAGTCCCCTCCCGTGGAACGTCTCGGGTACGTTCGCCAGCGACGTACTACGGGGGGTTTGGCACTAACGGCGGTTAAGCGCTTTTTGAGCACGGAGCATGGGTGCCCGGCTTGCCTCATGAGCAGGAACTTGGTGGTGAAATTCATATGGCCTTGGGATTAAAGCGAATGGCACAGTTCTGTTTCAAACCGGATCTTGCCCAGAGTCGGCTCTCACCCCTCGCAATAGTACGAATTCTCACATGTCGCACGCAGTGGCGGGAATATCAAAAAGAGGTCACGTTCGACTCGTCCTGAGTTGTCTATTGCGTGAACTCGAGTTTGCCTAGGTTGGGACTTCCTACGGCTGTCACAAGAAGGTGGGTGTATAATTGGCAGTCCCACCTCCCCGAGGCCTATGACATTAACCTCCATGAGTGGAAGAATCGGGAGGTCCAGCAGCACGTGCGTCGGACGTTCACACTGTTTTCGGCAACGGGTTCACCGGCGAAGAGCTAAGCGAGAAGTTGAAGGCACCTTATCATTGCTACACATTCAGAAGGATGATACCGGTACTACGTCGGGATTCGTGCATGGCACTTACGCTGCTTCCGAGCAGTATACGTCATCGCAACCTTTCGTTTATGTTGTCACCACTTCTGGCGTTGCGAATATACATTATTAGAGATCCGATGAGCCTAAACGAGAAAATACCTAAGCAGCTAGGATAAGTCGTCGTGCAACTAGCGAGACGCTAACCAGATCTATGCTTTCTAGAGCTATCAAGATCCAAATTGTATAGCAATCCCTGCTTACAAGCACATTAATGTAACATACAGCAGGTACACGTGCATGGGTTCTCGCTCCAGCCAACTCTTATGCCCAACCTATTTCGGGGGTACGGTATGTATTCAGGATACTGTTGAGTGTTTCGCTTACAGGGTGCGGACGTATTCCGGACTTTCTTGTGCTCTCATTTGCTTTGGTCGTTGTAGACTGGACCGTCGCCCGTAGTAAACATAGTAGAAAATTTTGTGGCTGTGGGCCCCGCTAGTTGCGCTAGCCGGTATTGCTTTCCGTAAGGATCCTTCCCTGGTACGCCCGAATACTTTACTACATGTTGACCTACTGTGTCTAGACCATCCTGCGACACGCGAGGGGCCCTGCCCAGCATTTATTCGAATTTGTAATATACCCTTGAACATGTGGGTGCTCACTCACCAGCTCCTTACCGGTTTCTCAACTTATTTTCAGGATTCATTTGCCACCGTGCGATTGCCCAGTGTGAGCGGCCTAACAAACTTCTCACATAAGGTGGGGTATTCCTGATCATGCAGTGCCTTTTAGTAGCTCCTTACCGAATGCTACTAGAGTCACTGGTGAATAAGATCGGACACTAGTTAGTAACAGCTGGGCATCAGATGGGTCAAGACTCAATCACGATCTTATCCAGCACCATCCCTGTAGGGGGAACGTAAGCGTCACGGTGTCATTTGGCCTTCTTATCCGCAGTACGCTAGTATCTTCGAACTTCTCTTTGCTACCGTAACTGTCCGAATTGAATCGAATTATAGATTTACGACTAGCTAAAATGAGTGCTAGCCAGAGCTGGCCTTACGTCTCTTTATGCTTCCACTCAACAGTTATTATGTTTTCCGACAGCTAGATGACCTGGGAGAAGAAAAAGTGACTTCAAGGAATCGACGTCAGCGCCGAGCGCTACCAGGCGCGTTGTAAGGCGTAAAAATGGCCCCGCAGTCTACCACAGAGACCGTTGGTTAATTTAACCGAATCGTACATGGTTTCCGACACCATGGGTGCGGAGCTAGCAAGGAATTAGAACAGAGGAGTGATGATCCGCTTCGGTTAGAAGGACCCCCCGAGGAAACTTATCCGTAGTAAAAGTGCCTCGCCGGTTTTCACGGCTCTACCATGTCTACATAAGACCATGCCCGCTCCTCTGGACGCGCGGCGTCGTGACCATTGTAGCGGGACACTTCGAGGTGTTGAAGGGGTACTAGTAGAAGGATCTCTTGCAACTTCCTCGATCCAGTGATGTGTCTGATCAGTATAGGCTAAACCCAGCTAGTGTACTCAGACAGTGAAACGGAGGGAACCTCTCCAACGACGGCTTGGGCACTGGGGCTCCAAGACCGCGCAGTTACCTGGTCTACGACAGCTCGAGTCCTCAGCTCAGAGCCTGGTCCTATAGTATGAAAACAGGTCGGGTGTCTCTTGCGGTGGCCTGACTCTCGTGTTACCCAGTAACATTTTTGTGACTCTCTATACTGTCGAAAGTGGTCAGCCCTGTCCAGTAAGGACCCGATTGAGTGCGTGAGTCCAACAATGAAGGCCCCTAGTATCAGGAAGAGCCCGTCTGGCTACTCCCCGTCTACCAAGGAGTAGGTCAGTGGTATGCAATACGTAGAACGAACGAGAGGGTGGGTCTGGTGTTCCTGAGTGTTGACTAGCGCCTTGGTTCGAAAGACTCCGATTATAGGTTCAAGATTTCATTATGCTGTCCAGAGAAACCTCAAAGGCGTCCAAATCTGCTCCCATTTGACCGGGCTTCCCGCGGAGGCCTTCAACGCTCGGCTCAAGACTGCAGAGAAAGCCCGCTGAATTTGCTTCTGTGACTTAGATGTTCAATGGCGATTGTCCTCGGATGTGAGAGGCATTCCTCTCGAACCTCAGTCCTCGTACAGAATGATCAACCAATGCTCTACCTAGATTCCACCATAGCACTAGCAGGCGTCGCTGTAGACAGGCGCACGCTACCCCCAACGTGATCTTCTGTAGGGCCAGCGTGCTCCGAAAGCAATCATATTTCATAAATATCTAAACGGCCGAGACGTAGCCTGCTTTTGGGACCTACATTAGAGATGCAGAGTAGTGAAATCACTCGTGGCTACGTCACGAAACGCAGGAAGCTGTATTACGTCTTATGACACTCGGGGTATGAGAGACGAGGGCGATATAGTTACCCTGTTACTGCGAGTATTTAATCTGACGGAGCCGATTGACACTCCTTTGACGGTAAAACTAATTAATCACTCAGGTGCACATGAAAACTTAGTGCATCTCAACCCGGTACGTAAAGGCGCCACGCCACCAACGTTTAGTCGCCCGCACTGTTCCTTTGGCTGGACCTCTAAGGAACGATAAAGAGCCAGCTGTAAAGTTGGCCCTGCTTTATGTTGCTGCGGTTCATCTATCCAGTTATCTGAACGGCTTCCGTAACTAGCTCATCTTATCCGGATTAAGGAAGGAGTGCTTCTCGGAAGCCGAACCCGAATGGGCAAAAGACAGGCCGGGTCATGCGTTCTACTTTCCACTAAAATAATGTTTGGCCGTGTTCTGGAAGACGAACTCGGCGGCTCTCGGCTAGTGAGCTCGAACTCCATTAGGCCACCACCTTGGTAGACCACCACCACAAGCTCATACCGTTTAATGGGGACCCGACGAGTGCCTGTGCAGACTATCTTGATGGATGACCCTTCAACATCCGGATGACCCGTCCCCGCGACTACCCGATCTTGACGAAGTTGTAGCGGTAGAAAACGCTTAAATCGTGCTTGTCGGCACAAGGGATCTCCTTTTTGGGTAGTCCGCAATAAGTATATGATACGGTTCCGGGTAAATCCTTACAGTTCTATTTCGTTTGGCAATTAGCGAAAATCGGCAGCGGTAACATAGGAACCTGGTGTCGTCGTCCCAGGGGACTGATTGTGGTTGCAGTAACACGGGAAGAATGAGCTACGTAGACTGCGGTGGAGCGCGAGACTTTTGCTTATTTGCCAAGATCGGGGCCATTTAACATTGGCCCGCAAACAGGCGTTAGCGTATATAGGTCACGAATTCGATCTTCGGGTATTGAGCGGGTTAGGCCCCGCGTATGAGAGGCGAGGATGGAATCCAAATGTCAAGGGTCTTTTTGAGGTATAGAAGAACGTGCCACCAAACGAATTATTCCTAGCGTAACTTGCTAAAACGGTTAATCAAAAAATCGCCTCGGAACCTGGCTAGACTCTTCGCTTAGTTGAATATGCGGGAAAATTCTCTGACACATGGTCCTCTACACAAACAGGCCCTAAAAGCAGACAAGTAAGATTAGCGCTAAGGGCGTGATTGTTTTCCCACATCTACCAACACGTGCATTCATTGAAACGAACTAGACAGGACCTGGCCGACCGTTTCTCTTAGCCAGCCATCAGTATTTACAGTAGCGGGAGATCTTTCGTAACACTGGGTTCAACGGGGCTGCCCGTCTTGAGATAACCCTGGATCGTCCGATATTATTTGCAATACTCCCCGTCAGTGTCGACCAACTTCCCCCGTCCCCTTGACCGTTAGTTTATGCACAGCGTGAAATATGACACCATGACGCAGCGTGACTTAGAGACTGATTTGAGGCGTGTGCATAGACGACTGCGATTATACTCCTAGTGAGACCGAATCCCTGGGTTATATGGGGAGACACAGTGCGAACAGCGAGGTGATCCCCGATGCAATGCGGAGCGTTCTGCCCTTCCTCAGCGAATCTCTTAAACGACCTCTGGCCGGCTCCACCTATGCATATCATTCACTAATGGACCGGGATGAGTGGTGTGTCTGGGCGGCTTTTCCTGTTGATCTTGTCCTTATCGACATTCACACATCACATGAGCATTGATTGTCACGCCACAAGTAACGGCAATGATAACCCCCGTACCAAAAAGACAGCTGTTCTATATTTTAGGGCTGCGCATCGCGCACTCAATTTATTCGGTAAGAGAGCGCCTTGAACCCGTGTGTGATCTGACTTACGCACAAGGATGAGGACCAGCCTCTGCTAACGACCAATACACTATGCTGCTTAGACTCTGTGAGACGATGGTTTCTTTAGTCGTTAAAAGGACTCCGAGGAGATTTTTGGTAAGCATTCGACTCTTTGACGGGCTTGGTGCAGTGACAAAAATGGTAGAACAGCCGCAGCAAGGATACTCGTATGTGACCACGTTTAGGGGCGCAGCACGATGCATAACGACTTAAGACGAACTCGCCTTCCTGAGATTGTCTATCTGGCTGACATAACCGCATATGAAGACACCCAGGGGTGTGTCAAATTGGCATACTCTACCTACACGACGCCACTAAATCACCTCCAGTAGCGCATCCTTCGGGAGTGTGCCTAATAATGCATGTTCCGGGATACTGAGAGAACACTAATTTCTGACTCTGTACACAATTACAACGTATGCTAGCTTAGGTAAATGCTCTTTCCTTCTAAACGGCTCACCCGATTATACCCTGTTTTGCAACTCCGAGGCCGGGCCATCTTCGCACGGCGTCTCGAAACGGATCTTCACAGCTTGGCGCAGTCATGGTGCTTATCCAATTAGCAGACCCACCCGCCTAGAATGACACCTGGAGACAATGTCGAGGCTATTCGGCGATTGAATCTGAATATTCTGCGTACGGCTGCGAGTCTGTAGAGTTGTCGACAGAGAGTGGGACATCGATGCTATATAGCAGAAGAAAGTTACCGAAGACTCCTTCACCGGTGGACGGATATTTTCGACGCTAAAGAGTGGAGCTCCAGAAGCCGGGCAAAGGGCAGCAACTAAGCATAGACGGCAGGGTGTGGTAAACGGACCAAACGCGTTTGGAAGATGGCAGCGGCACAACTGGCCGATACTCAATTCGAAGGCTACGGGTCGGCGGCGA")
#.complement gives complement
# print(dna_seq.complement())
#reverse_dna_seq = dna_seq[::-1]
#.reverse_complement gives reverse complement
# print(dna_seq.reverse_complement())   




#READING FASTA FILES
#for seq_record in SeqIO.parse("ls_orchid.fasta", "fasta"):
    # print(seq_record.id)
    # print(repr(seq_record.seq))
    # print(len(seq_record))



#CONVERTING FASTA FILE TO DICTIONARY 
# record_dict = SeqIO.to_dict(SeqIO.parse("example.fasta", "fasta"))



#Since each k-mer requires |Text| − k + 1 such checks, each one requiring as many as k comparisons,
# the overall number of steps of PatternCount(Text, Pattern) is (|Text| − k + 1) · k. 
# Furthermore, FrequentWords must call PatternCount |Text| − k + 1 times (once for each k-mer of Text),
# so that its overall number of steps is (|Text| − k + 1) · (|Text| − k + 1) · k. To simplify the matter, 
# computer scientists often say that the runtime of ﻿FrequentWords has an upper bound of |Text|2 · k steps and refer to the complexity of this algorithm as O(|Text|2 · k).


#WITHOUT MAP
def FrequentWords(Text, k):  # Complexity = O(|Text|^2 · k)
    FrequentPatterns = []
    count_array =[]
    for i in range(0,len(Text) - k):
        Pattern = Text[i:k]
        count_array.append(PatternCount(Text, Pattern))
    maxCount = max(count_array)
    for i in range(0,len(Text) - k):
        if maxCount(i) == maxCount:
            FrequentPatterns.append(Text[i:k])
    FrequentPatterns_2 = []        
    for x in FrequentPatterns:
        if x not in FrequentPatterns_2:
            FrequentPatterns_2.append(x)
    return FrequentPatterns_2


#WITH MAP
def better_FrequentWords(text, k):
    frequency = {}
    for i in range(0, len(text) - k + 1):
        kmer = text[i: i + k]
        if not kmer in frequency:
            frequency[kmer] = 0
        frequency[kmer] += 1
    all_values = [frequency.values()]    
    max_freq = max(all_values)
    most_freq_patterns = [x for x in frequency.keys() if frequency[x] == max_freq]
    return frequency, most_freq_patterns
    # return max(frequency, key = frequency.get)    

#print(better_FrequentWords("enter text",#enter k))


#DIFFERENT GENOME< DIFFERENT HIDDEN MESSAGE

#CLUMP FINDING PROBLEM

def FindClumps(Text, k, L, t):
    Patterns = [] 
    n = len(Text)
    for i in range(0,n - L):
        Window = Text[i:i+L]
        freqMap,_ = better_FrequentWords(Window, k)
        for s in freqMap.keys():
            if freqMap[s] >= t:
                Patterns.append(s)
    Patterns_2 = []        
    for x in Patterns:
        if x not in Patterns_2:
            Patterns_2.append(x)
    return Patterns_2
 
#print(FindClumps("enter Genome here", 12, 495, 19))


def min_skew(genome):
    diff = 0
    skew = []
    for i, c in enumerate(genome):
        if c == 'G':
            diff += 1
        if c == 'C':
            diff -= 1
        skew.append(diff)
    m = min(skew)
    answers = []
    for i, d in enumerate(skew):
        if d == m:
            answers.append(i + 1)
    return answers   


#print(min_skew("enter genome here"))             
#AT THE MOST ONE MISMATCH, ALL THESE FUNCTIONS ARE NEEDED

def hamming_distance(p, q):
    l = len(p)
    d = 0
    for i in range(l):
        if p[i] != q[i]:
            d += 1
    return d

# print(hamming_distance("enter first string", "enter second string" ))    

def approximate_match(p, q, d):
    if hamming_distance(p, q) <= d:
        return True
    return False


# print(approximate_match("enter first string", "enter second string", enter difference ))


def find_approximate_matches(text, pattern, d):
    count = 0
    l = len(pattern)
    for i in range(0, len(text) - l + 1):
        if approximate_match(pattern, text[i: i + l], d):
            print(i)
            count += 1
    return count            


print(find_approximate_matches("AACAAGCTGATAAACATTTAAAGAG","CAG", 1))












# REFER TO OTHER TWO SCRIPTS FOR THIS PART BELOW
#Frequent Words with Mismatch and Reverse Complement Problem

def reverse_complement(seq):
    rc = ''
    for c in seq[-1::-1]:
        if c == 'G':
            rc += 'C'
        if c == 'C':
            rc += 'G'
        if c == 'A':
            rc += 'T'
        if c == 'T':
            rc += 'A'
    return rc



def generate_neighborhood(seq):
    neighborhood = {}
    bases = ['A', 'C', 'G', 'T']
    for i in range(len(seq)):
        for d in bases:
            if seq[i] != d:
                tmp = seq[:i] + d + seq[i + 1:]
                neighborhood[tmp] = True
    neighborhood[seq] = True
    return neighborhood




def frequent_words_with_mismatch(text, k, d):
    frequency = {}
    neighborhoods = {}
    for i in range(0, len(text) - k + 1):
        kmer = text[i: i + k]
        if not kmer in neighborhoods:
            neighborhoods[kmer] = generate_neighborhood(kmer)
            #neighborhoods[kmer].update(generate_neighborhood(reverse_complement(kmer)))
        for seq in neighborhoods[kmer]:
            if not seq in frequency:
                frequency[seq] = 0
            frequency[seq] += 1      
    # m_key = max(frequency, key = frequency.get)
    m_value = max(frequency.values())
    for key in frequency:
        if frequency[key] == m_value:
            print(key)      



#print(frequent_words_with_mismatch("AATTAATTGGTAGGTAGGTA", 4, 0))




